# Cookie Edition

1. On se rend sur http://192.168.1.16/index.php

Avec l'inspecteur d'élément, dans l'onglet Application (Chrome), on peut voir les cookies
Il se trouve qu'il y a un cookie du nom de "I_am_admin" avec un valeur ressemblant à un hash
On peut copier coller ce hash dans Google : on voit rapidement qu'il s'agit du hash MD5 de "false", qui coincide avec le nom du cookie btw

2. Toujours dans l'inspecteur, on peut éditer le cookie, manuellement

Logiquement, essayons de mettre le hash MD5 de "true" qui est : b326b5062b2f0e69046810717534cb09

On refresh, et hop, une alert avec le flag dedans :) A noter que seul la valeur "true" semble fonctionner

# Protection

Les cookies sont utilisés pour identifier la session de l’utilisateur et permettre au serveur de reconnaître celui-ci tout au long de sa navigation,
les cookies contiennent souvent des informations personnelles et/ou sensibles.
Pour rappel, un cookie est généralement créé sur le navigateur à la demande du serveur web pour stocker un état, qui sera ensuite retransmis sur les prochaines requêtes.
Le serveur web utilise pour cela l’en-tête Set-Cookie dans une réponse HTTP

    Set-Cookie: <name>=<value>[; <Max-Age>=<age>] [; expires=<date>][; domain=<domain_name>] [; path=<some_path>][; secure][; HttpOnly]

Possible pour le serveur de définir un chemin et un domaine pour lequel le cookie devra être utilisé.
Un cookie n’est par défaut envoyé que sur le domaine responsable de l’avoir placé.
Les instructions domain et path permettent éventuellement de restreindre sa portée, ou inversement de l’étendre


1. Tips 1 : Une première bonne pratique pour la sécurisation de vos cookies consiste justement à bien en maîtriser leurs portées respectives.

Un cookie peut-être positionné et utilisé par un serveur web, mais aussi directement sur le navigateur en Javascript.
Dans le cas d’une faille XSS, un attaquant pourrait parvenir à injecter du Javascript, et donc potentiellement accéder aux cookies.

2. Tips 2 : L’utilisation de l’instruction “HttpOnly” au moement de set le cookie empêche d’accéder aux cookies en Javascript

3. Utiliser l'attribut "secure" lors au moment de set le cookie afin que celui-ci soit inaccessible en HTTP, uniquement en HTTPs

4. Le flag "SameSite" (Lax|Strict)

Rappel CSRF : A CSRF is an unwanted request made by site A to site B while the user is authenticated on site B.
Traditionally, there have been 2 ways to get rid of CSRF: the headers Origin and Referer but the best one is the CSRF token

SameSite cookies aim to supersede the solutions mentioned above once and for all.
When you tag a cookie with this flag, you tell the browser not to include the cookie in requests that were generated by different origins.
When the browser initiates a request to your server and a cookie is tagged as SameSite, the browser will first check whether the origin of the request is the same origin that issued the cookie.
If it’s not, the browser will not include the cookie in the request.

One-Liner Remember : SameSite=Lax|Strict will prevent the browser from sending it in cross-origin requests, rendering any kind of CSRF attack ineffective

-----


5. HTTPS, comme toujours, autrement le site et l'utilisateur seront vulnérable aux attaques "man in the middle"

# Bonus

Utile à savoir : When a server sends a cookie without setting its Expires or Max-Age, browsers treat it as a session cookie

TLD-cookies (cookie set on domain like .com, .org ...), otherwise known as supercookies, are disabled by web browsers for security reasons 

